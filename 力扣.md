# 1

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<Integer,Integer>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target-nums[i])){
                return new int[]{i,map.get(target-nums[i])};
            }
            map.put(nums[i],i);
        }
        return new int[0];
    }
}
```

# 3

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashMap<Character, Integer> map = new HashMap();
        int length = s.length();
        int left = 0;
        int right =0;
        int max = 0;
        while(right<length){
            char rightChar = s.charAt(right);
            right++;
            map.put(rightChar,map.getOrDefault(rightChar,0)+1);
            while(map.get(rightChar)>1){
                char leftChar = s.charAt(left);
                left++;
                map.put(leftChar,map.get(leftChar)-1);
                
            }
            max = Math.max(max,right-left);
        }
        
        return max;
    }
}
```



# 5

```java
class Solution {
    public String longestPalindrome(String s) {
        if(s == null||s.length()==0){
            return s;
        }

        int len = s.length();
        String longest = "";

        for(int i=0;i<len;i++){
            String odd = isPalindrome(s,i,i);
            String even = isPalindrome(s,i,i+1);

            if(odd.length()>longest.length()){
                longest = odd;
            }
            if(even.length()>longest.length()){
                longest = even;
            }

        }

        return longest;

    }

    public String isPalindrome(String s,int left,int right){
        while(left>=0&&right<s.length()&&s.charAt(left)==s.charAt(right)){
            left--;
            right++;
        }
        return s.substring(left+1,right);
    }
}
```



# 11

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length-1;
        int max = 0;
        while(left<right){
            int area = (right-left)*Math.min(height[left],height[right]);
            max = Math.max(max,area);
            if(height[left]>height[right]){
                right--;
            }else{
                left++;
            }
        }
        return max;
    }
}
```

# 15

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        for(int first = 0;first<n;first++){
            if(first>0&&nums[first]==nums[first-1]){
                continue;
            }
            int third = n-1;
            int target = -nums[first];

            for(int sec = first+1;sec <n;sec++){
                if(sec >first+1&&nums[sec]==nums[sec-1]){
                    continue;
                }
                while(sec<third&&nums[sec]+nums[third]>target){
                    third--;
                }
                if(third==sec){
                    break;
                }
                if(nums[sec]+nums[third]==target){
                    List<Integer> list = new ArrayList<Integer>();
                    list.add(nums[first]);
                    list.add(nums[sec]);
                    list.add(nums[third]);
                    ans.add(list);
                }
            }

        }
        return ans;
    }
}
```

# 21

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1==null){
            return list2;
        }else if(list2==null){
            return list1;
        }else if(list1.val<list2.val){
            list1.next =  mergeTwoLists(list1.next,list2);
            return list1;
        }else{
            list2.next =  mergeTwoLists(list1,list2.next);
            return list2;
        }
    }
}
```



# 26	

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        int left = 1;
        int right = 1;
        while(right<nums.length){
            if(nums[right]==nums[right-1]){
                right++;
            }else{
                nums[left]=nums[right];
                left++;
                right++;
            }
        }
        return left;
    }
}
```

# 53

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        int pre = 0;
        for(int num:nums){
            pre = Math.max(pre+num,num);
            ans = Math.max(pre,ans);
        }
        return ans;
    }
}
```



# 56

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals == null||intervals.length==0||intervals[0]==null||intervals[0].length==0){
            return new int[0][0];
        }
        Arrays.sort(intervals, (v1, v2) -> v1[0] - v2[0]);
        List<int[]> mergeList = new ArrayList<>();


        for(int i=0;i<intervals.length;i++){
            int left = intervals[i][0];
            int right = intervals[i][1];

            if(mergeList.size()==0||mergeList.get(mergeList.size()-1)[1]<left){
                mergeList.add(new int[]{left,right});
            }else{
                mergeList.get(mergeList.size()-1)[1] = Math.max(right,mergeList.get(mergeList.size()-1)[1]);
            }
        }

        int[][] results = new int[mergeList.size()][2];
        for(int i=0;i<mergeList.size();i++){
            results[i] = mergeList.get(i);
        }
        return results;
    }
}
```



# 75

```java
class Solution {
    public void sortColors(int[] nums) {
        int n = nums.length;
        int p0=0;
        int p1=0;
        for(int i=0;i<n;i++){
            if(nums[i]==1){
                int temp = nums[i];
                nums[i] = nums[p1];
                nums[p1] = temp;
                ++p1;
            }else if(nums[i]==0){
                int temp = nums[i];
                nums[i] = nums[p0];
                nums[p0] = temp;
                if(p0<p1){
                    temp = nums[i];
                    nums[i] = nums[p1];
                    nums[p1] = temp;
                }
                ++p0;
                ++p1;
            }
        }
    }
}
```



# 80	

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int left = 2;
        int right =2;
        if(nums.length <= 2){
            return nums.length;
        }
        while(right<nums.length){
            if(nums[left-2]==nums[right]){
                right++;
            }else{
                nums[left]=nums[right];
                right++;
    
                left++;                                                                
            }
        }
        return left;
    }
}
```

# 86

```java
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode small = new ListNode(0);
        ListNode smallHead = small;
        ListNode large = new ListNode(0);
        ListNode largeHead = large;
        while (head != null) {
            if (head.val < x) {
                small.next = head;
                small = small.next;
            } else {
                large.next = head;
                large = large.next;
            }
            head = head.next;
        }
        large.next = null;
        small.next = largeHead.next;
        return smallHead.next;
    }
}
```

# 94

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode node = root;

        while(node!=null||!stack.isEmpty()){
            if(node!=null){
                stack.push(node);
                node = node.left;
            }else{
                node = stack.pop();
                res.add(node.val);
                node=node.right;
            }
        }
        return res;
    }
}
```

# 88

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 =0;
        int p2 = 0;
        int index = 0;
        int[] sorted = new int[m + n];
        while(p1<m && p2<n){
            if(nums1[p1]<=nums2[p2]){
                sorted[index]=nums1[p1];
                p1++;
            }else{
                 sorted[index]=nums2[p2];
                 p2++;
            }
            index++;
        }

        while(p1<m){
            sorted[index]=nums1[p1];
            p1++;
            index++;
        }
        while(p2<n){
            sorted[index]=nums2[p2];
            p2++;
            index++;
        }

        for(int i = 0;i<nums1.length;i++){
            nums1[i]=sorted[i];
        }
    }
}
```

# 98

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
         return isValidBST(root, null, null);
    }

    public boolean isValidBST(TreeNode root,TreeNode min,TreeNode max){
        if(root==null){
            return true;
        }

        if(min!=null&&root.val<=min.val){
            return false;
        }

        if(max!=null&&root.val>=max.val){
            return false;
        }

        return isValidBST(root.left,min,root)&&isValidBST(root.right,root,max);
    }
}
```



# 100

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null&&q==null){
            return true;
        }

        if (p == null || q == null) {
            return false;
        }

        if(p.val!=q.val){
            return false;
        }

        return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
    }
}
```

# 101

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root,root);
    }

    public boolean check(TreeNode left,TreeNode right){
        if(left == null&&right==null){
            return true;
        }

        if(left == null || right == null){
            return false;
        }

        if(left.val != right.val){
            return false;
        }

        return check(left.left,right.right)&&check(left.right,right.left);
    }
}
```



# 102

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root ==null){
            return new ArrayList<>();
        }

        List<List<Integer>> ans = new ArrayList<>();
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i = 0;i<size;i++){
                TreeNode node = queue.poll();
                if(node.left!=null){
                    queue.offer(node.left);
                }
                if(node.right !=null){
                    queue.offer(node.right);
                }

                list.add(node.val);
            }
            ans.add(list);
        }
        return ans;
    }
}
```



# 103

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if(root == null){
            return new ArrayList<>();
        }

        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int flag = 0;
        
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> level = new LinkedList<>();
            for(int i = 0;i<size;i++){
                TreeNode node = queue.poll();
                if(node.left !=null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
                level.add(node.val);

            }
            if(flag%2!=0){
                Collections.reverse(level);
            }
            flag++;
            ans.add(level);

        }

        return ans;
    }
}
```

# 104

```java
class Solution {
    int max = 0;
    public int maxDepth(TreeNode root) {
        if(root == null){
            return max;
        }

        max_depth(root,1);
        return max;
    }

    public void max_depth(TreeNode root,int depth){
        if(root==null){
            return;
        }

        max = Math.max(max,depth);

        max_depth(root.left,depth+1);
        max_depth(root.right,depth+1);
    }
}
```

# 107

```java

class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        if(root == null){
            return new ArrayList<>();
        }
        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();

        queue.offer(root);
        while(!queue.isEmpty()){
            int size= queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i =0;i<size;i++){
                TreeNode node = queue.poll();
                if(node.left !=null){
                    queue.offer(node.left);
                }
                if(node.right!=null){
                    queue.offer(node.right);
                }
                list.add(node.val);
            }
            ans.add(list);  
        }
        Collections.reverse(ans);
        return ans;
    }
}
```



# 111

```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        if(root.left==null&&root.right ==null){
            return 1;
        }
        
        int min_depth = Integer.MAX_VALUE;
        if(root.left!=null){
            min_depth = Math.min(minDepth(root.left),min_depth);
        }

        if(root.right!=null){
            min_depth = Math.min(minDepth(root.right),min_depth);
        }

        return min_depth+1;
    }
}
```

# 112

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null){
            return false;
        }

        return dfs(root,targetSum,0);
    }

    public boolean dfs(TreeNode root, int targetSum,int preSum){
        if(root==null){
            return false;
        }

        int curSum = preSum+root.val;

        if(root.left == null&&root.right==null&&curSum==targetSum){
            return true;
        }

        return  dfs( root.left,targetSum, curSum)|| dfs(root.right, targetSum, curSum);
    }
}
```



# 113

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<Integer> path = new ArrayList<>();
        dfs(root,targetSum,0,path);
        return res;
    }

    public void dfs(TreeNode root, int targetSum,int curSum, List<Integer> path){
        if(root == null){
            return;
        }
        curSum = curSum + root.val;
        path.add( root.val);

        if(root.left==null&&root.right==null&&targetSum==curSum){
            res.add(new ArrayList<>(path));
            path.remove(path.size()-1);
            return;
        }

        dfs(root.left,targetSum,curSum,path);
        dfs(root.right,targetSum,curSum,path);

        path.remove(path.size()-1);

    }
}
```



# 125

```java
class Solution {
    public boolean isPalindrome(String s) {
        StringBuffer sgood = new StringBuffer();
        int length = s.length();
        for(int i=0;i<length;i++){
            char c1 = s.charAt(i);
            if(Character.isLetterOrDigit(c1)){
                sgood.append(Character.toLowerCase(c1));
            }
        }
        StringBuffer temp = new StringBuffer(sgood);
        StringBuffer reversed  = temp.reverse();
        
     
        return sgood.toString().equals(reversed.toString());
    }
}
```



# 141

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
```

# 142

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(true){
            if(fast == null ||fast.next == null) return null;
            fast = fast.next.next;
            slow = slow.next;
            if(fast==slow) break;
        }
        fast = head;
        while(fast != slow){
            fast = fast.next;
            slow = slow.next;
        }
        return fast;
    }
}
```



# 144

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode node =root;

        while(node!=null||!stack.isEmpty()){
            if(node!=null){
                res.add(node.val);
                stack.push(node);
                node=node.left;
            }else{
                node=stack.pop();
                node=node.right;
            }
        }
        return res;
    }
}
```



# 151

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    let i =0,j=1,result ='',len = s.length;
    while(i<len){
       if(s[i]===' '){
           i++;
       }else{
           j=i+1;
           let ret = s[i];
           while(j<len){
               if(s[j]===' '){
                   break;
               }
               ret += s[j];
               j++;
           }
           result = ret + (result.length ? ' ' + result : '');
           i=j;
       }
    }
    return result;
};
```



# 160

```java	

public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode a = headA;
        ListNode b = headB;
        if (headA == null || headB == null) return null;
        int aSize = 0;
        int bSize = 0;
       
        while(a!=null){
            aSize++;
            a = a.next;
        }
        while(b!=null){
            bSize++;
            b = b.next;
        }
        int diff = aSize-bSize;
        if(diff > 0){
            for(int i =0;i<diff;i++){
                headA = headA.next;
            }
 
        }else{
            diff=-diff;
            System.out.println(diff);
            for(int j =0;j<diff;j++){
                headB = headB.next;
            }

        }
        while(headA !=null){
            if(headA == headB){
                return headA;
            }else{
                headA = headA.next;
                headB = headB.next;
            }
        }
        return null;
    }
}
```



# 167

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length-1;
        while(left<right){
            if(numbers[left]+numbers[right] >target){
                right--;
            }else if(numbers[left]+numbers[right] < target){
                left++;
            }else{
                return new int[]{left+1,right+1};
            }
        }
        return new int[]{-1,1};
    }
}
```

# 173

```java
class BSTIterator {

    List<Integer> list = new LinkedList<>();
    public BSTIterator(TreeNode root) { 
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode node = root;
        while(node!=null||!stack.isEmpty()){
            if(node!=null){
                stack.push(node);
                node = node.left;
            }else{
                node = stack.pop();
                list.add(node.val);
                node= node.right;
            }
        }
    }
    
    public int next() {
        return list.remove(0);
    }
    
    public boolean hasNext() {
        return !list.isEmpty();
    }
}

```

# 199

```java
class Solution {
     List<Integer> res = new ArrayList<>();
    public List<Integer> rightSideView(TreeNode root) {
        if(root==null){
            return res;
        }

        Queue<TreeNode> queue  = new LinkedList<>();
        queue.offer(root);

        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> layer = new ArrayList<>();

            for(int i =0;i<size;i++){
                TreeNode node = queue.poll();
                layer.add(node.val);

                if(node.left!=null){
                    queue.offer(node.left);
                }
                if(node.right!=null){
                    queue.offer(node.right);
                }
            }

            res.add(layer.get(layer.size()-1));
        }

        return res;
    }
}
```

# 200

```java
class Coordinate{
    int x;
    int y;
    public Coordinate(int x, int y){
        this.x=x;
        this.y=y;
    }
}


class Solution {
    public static int[] directionX = new int[] {-1,0,1,0};
    public static int[] directionY= new int[] {0,1,0,-1};
    public int numIslands(char[][] grid) { 
        if(grid==null||grid.length==0||grid[0]==null||grid[0].length==0){
            return 0;
        }
        int row = grid.length;
        int col = grid[0].length;

        int numIslands=0;
        boolean[][] visited = new boolean[row][col];
        
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j] == '1' && !visited[i][j]){
                    bfs(i,j,grid,visited);
                    numIslands++;
                }
            }
        }
        return numIslands;
    }

    public void bfs(int x, int y, char[][] grid, boolean[][] visited){
        Queue<Coordinate> queue = new LinkedList<>();
        queue.offer(new Coordinate(x,y));

        visited[x][y] = true;

        while(!queue.isEmpty()){
            Coordinate curr = queue.poll();

            for(int i=0;i<4;i++){
                int newX = curr.x + directionX[i];
                int newY = curr.y + directionY[i];

                if(!isValid(newX,newY,grid,visited)){
                    continue;
                }

                queue.offer(new Coordinate(newX,newY));
                visited[newX][newY] = true;
            }
        }
    }

    public boolean isValid(int x, int y, char[][] grid, boolean[][] visited){
        if(x<0||x>=grid.length||y<0||y>=grid[0].length){
            return false;
        }
        if(visited[x][y] == true){
            return false;
        }

        return grid[x][y] == '1';
    }
}
```



# 209

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int right = 0;
        int min = Integer.MAX_VALUE;
        int sum = 0;
        int length = nums.length;
        if(length == 0){
            return 0;
        }
        while(right<length){
            sum = sum+nums[right];
            right++;
            while(sum>=target){
                min = Math.min(min,right-left);
                sum = sum-nums[left];
                left++;
             
            }
            
        }
        return min == Integer.MAX_VALUE ? 0 : min;
    }
}
```



# 215

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int length = nums.length;
        PriorityQueue<Integer> miniHeap = new PriorityQueue<>(k,(a,b)->a-b);
        for(int i =0;i<k;i++){
            miniHeap.add(nums[i]);
        }
        for(int j = k;j<length;j++){
            if(nums[j]>miniHeap.peek()){
                miniHeap.poll();
                miniHeap.offer(nums[j]);
            }
        }
        return miniHeap.peek();
    }
}
```

# 230

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        ArrayList<Integer> list = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode node = root;

        while(!stack.isEmpty()||node != null){
            if(node!=null){
                stack.push(node);
                node = node.left;
            }else{
                node=stack.pop();
                list.add(node.val);
                node=node.right;
                
            }
        }
       return list.get(k-1);
    }
}
```



# 234

```java

class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer> vals = new ArrayList<Integer>();
        ListNode node = head;
        while(node!=null){
            vals.add(node.val);
            node = node.next;
        }

        int start=0;
        int end = vals.size()-1;
        while(start<end){
            if(vals.get(start)!=vals.get(end)){
                return false;
            }else{
                start++;
                end--;
            }
        }
        return true;
    }
}
```



# 238

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int length = nums.length;
        int[] l = new int[length];
        int[] r = new int[length];
        int[] ans = new int[length];

        l[0]=1;
        for(int i=1;i<length;i++){
            l[i] = nums[i-1]*l[i-1];
        }
        
        r[length-1]=1;
        for(int i=length-2;i>=0;i--){
           r[i] = r[i+1]*nums[i+1];
        }

        for(int i= 0;i<length;i++){
            ans[i] = l[i]*r[i];
        }

        return ans;
    }
}
```



# 283

```java
class Solution {
    public void moveZeroes(int[] nums) {
        if(nums==null){
            return;
        }
        int p1 = 0;
        int p2 = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=0){
                int temp = nums[p2];
                nums[p2]=nums[i];
                nums[p1]=temp;
                p2++;
            }
            p1++;
        }
    }
}
```

# 287

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int length = nums.length;
        int[] index = new int[length+1];
        for(int i = 0;i<length;i++){
            if(index[nums[i]]==1){
                return nums[i];
            }else{
               index[nums[i]]=1;
            }
        }
        return 0;
    }
}
```

# 303

```java
class NumArray {
    int[] sums;

    public NumArray(int[] nums) {
        int n = nums.length;
        sums = new int[n+1];
        for(int i =0;i<n;i++){
            sums[i+1] = nums[i]+sums[i];
        }
    }
    
    public int sumRange(int left, int right) {
        return sums[right+1]-sums[left];
    }
}
```



# 328

```java
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head == null) {
            return head;
        }
        ListNode evenHead = head.next;
        ListNode odd = head, even = evenHead;
        while (even != null && even.next != null) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
}
```



# 345

```java	
class Solution {
    public String reverseVowels(String s) {
        int n = s.length();
        char[] arr = s.toCharArray();
        int i =0;
        int j = n-1;
        while(i<j){
            while(i<n&&!isAEIOU(arr[i])){
                i++;
            }
            while(j>0&&!isAEIOU(arr[j])){
                j--;
            }
            if(i<j){
                swap(arr,i,j);
                i++;
                j--;
            }
        }
        return new String(arr);

    }

    public Boolean isAEIOU(char c){
        return "aeiouAEIOU".indexOf(c)>=0;
    }

    public void swap(char[] arr,int i,int j){
        char temp = arr[i];
        arr[i]=arr[j];
        arr[j] = temp;
    }
}
```



# 347

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer,Integer> map = new HashMap();
        for(int num : nums){
            if(map.containsKey(num)){
                map.put(num,map.get(num)+1);
            }else{
                map.put(num,1);
            }
        }

        PriorityQueue<Integer> miniHeap = new PriorityQueue<>(new Comparator<Integer>(){
            @Override
            public int compare(Integer a, Integer b){
                return map.get(a) - map.get(b);
            }
        });
        for(int key : map.keySet()){
            if(miniHeap.size()<k){
                miniHeap.add(key);
            }else{
                if(map.get(key)>map.get(miniHeap.peek())){
                    miniHeap.remove();
                    miniHeap.add(key);
                }
            }
        }

        int[] ans  = new int[k];
        for(int i = 0; i < k; i++){
            ans[i] = miniHeap.poll();
        }
        return ans;
    }
}
```

# 349

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int l1=nums1.length;
        int l2=nums2.length;
        int[] ans = new int[l1+l2];
        int index1=0;
        int index2=0;
        int index=0;
        while(index1<l1&&index2<l2){
            if(nums1[index1]==nums2[index2]){
                if(index==0||ans[index-1]!=nums1[index1]){
                    ans[index]=nums1[index1];
                    index++;
                }
                index2++;
                index1++;
            }else if(nums1[index1]>nums2[index2]){
                index2++;
            }else{
                index1++;
            }
        
        }
        ans = Arrays.copyOfRange(ans, 0, index);
        return ans; 
    }
}
```

# 350

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        if(nums1.length>nums2.length){
            return intersect( nums2, nums1);
        }

        HashMap<Integer,Integer> map = new HashMap<Integer, Integer>();
        for(int num : nums1){
            int counter = map.getOrDefault(num,0)+1;
            map.put(num,counter);
        }

        int index = 0;
        int[] ans = new int[nums1.length];
        for(int num:nums2){
            int counter = map.getOrDefault(num,0);
            if(counter>0){
                ans[index] = num;
                index++;
                counter--;
                if(counter==0){
                    map.remove(num);
                }else{
                    map.put(num,counter);
                }
            }
        }
        ans = Arrays.copyOfRange(ans, 0, index);
        return ans;
    }
}
```

# 513

```java

class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        TreeNode node = null;
        queue.offer(root);
        while(!queue.isEmpty()){
            node = queue.poll();
            if(node.right !=null){
                queue.offer(node.right);
            }
             if(node.left!=null ){
                queue.offer(node.left);
            }
        }
        return node.val;
    }
}
```



# 543

```java
class Solution {
    int max = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root==null){
            return 0;
        }

        dfs(root);
        return max;
    }

    public int dfs(TreeNode root){
        if(root == null){
            return 0;
        }

        int maxLeft = dfs(root.left);
        int maxRight = dfs(root.right);
        max = Math.max(max,maxLeft+maxRight);
 
        return Math.max(maxLeft,maxRight)+1;
    }
}
```



# 557

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    const ret = [];
    let i = 0;
    len = s.length;
    while(i<len){
        let start = i;
        while(s.charAt(i)!= ' '&&i<len){
            i++;
        }
        for(let p = start;p<i;p++){
            ret.push(s.charAt(i-1+start-p));
        }
        while(i<len&&s.charAt(i) == ' '){
            i++;
            ret.push(' ');
        }
        console.log(ret)
    }
    return ret.join('');
};
```



# 567

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        Map<Character,Integer> need = new HashMap<>();
        Map<Character,Integer> window = new HashMap<>();
        int left = 0;
        int right = 0;
        int count = 0;

        for(int i = 0;i<s1.length();i++){
            char c = s1.charAt(i);
            need.put(c,need.getOrDefault(c,0)+1);
        }

        while(right<s2.length()){
            char rightChar = s2.charAt(right);
            right++;
            if(need.containsKey(rightChar)){
                window.put(rightChar,window.getOrDefault(rightChar,0)+1);
                if(need.get(rightChar).equals(window.get(rightChar))){
                    count++;
                }
            }

            while(right - left >= s1.length()){
                if(count == need.size()){
                    return true;
                }

                char leftChar = s2.charAt(left);
                left++;

                if(need.containsKey(leftChar)){
                    if(need.get(leftChar).equals(window.get(leftChar))){
                        count--;
                    }
                    window.put(leftChar,window.get(leftChar)-1);
                }
            }
        }

        return false;
    }
}
```

# 653	

```java
class Solution {
   List<Integer> list = new ArrayList<Integer>();
    public boolean findTarget(TreeNode root, int k) {
        getTreeArray(root);
      
        int left = 0;
        int right = list.size()-1;
       while(left<right){
        if(list.get(left)+list.get(right)>k){
            right--;
        }else if(list.get(left)+list.get(right)<k){
            left++;
        }else{
            return true;
        }
       }
  
        return false;
    }

    public void getTreeArray(TreeNode root){
        if(root == null ){
            return;
        }
      
        getTreeArray(root.left);
        list.add(root.val);
        getTreeArray(root.right);
        


    }
}
```



# 680

```java
class Solution {
    public boolean validPalindrome(String s) {
        int start = 0;int end = s.length() -1;
        while(start<end){
            char c1 = s.charAt(start);
            char c2 = s.charAt(end);
            if(c1==c2){
                start++;
                end--;
            }else{
                return isPalindrome( s, start+1, end)||isPalindrome( s, start, end-1);
            }
        }
        return true;
    }

    public boolean isPalindrome(String s,int start,int end){
        for(int i=start,j = end;i<j;i++,j--){
            char c1 = s.charAt(i);
            char c2 = s.charAt(j);
            if(c1!=c2){
                return false;
            }
        }
        return true;
    }
}
```

# 703

```java
class KthLargest {
    PriorityQueue<Integer> pq;
    int k;

    public KthLargest(int k, int[] nums) {
        this.k = k;
        pq = new PriorityQueue<>();
        for(int num:nums){
            add(num);
        }
    }
    
    public int add(int val) {
        pq.offer(val);
        if(pq.size()>k){
            pq.poll();
        }
        return pq.peek();
    }
}
```

# 704

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length-1;
        while(left+1<right){
            int mid = left+(right-left)/2;
            if(nums[mid]>target){
                right= mid;
            }else if(nums[mid]<target){
                left=mid;
            }else{
                return mid;
            }
        }
        
        if(nums[left]==target){
            return left;
        }
        if(nums[right]==target){
            return right;
        }
        return -1;
    }
}
```



# 733

```java
class Coordinate{
    int x;
    int y;
    public Coordinate(int x, int y){
        this.x = x;
        this.y=y;
    }
}

class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        if(image == null||image.length==0||image[0]==null||image[0].length==0){
            return new int[0][0];
        }

        int row = image.length;
        int col = image[0].length;

        int[] dx = new int[]{0,0,-1,1};
        int[] dy = new int[]{-1,1,0,0};

        boolean[][] visited = new boolean[row][col];

        Queue<Coordinate> queue = new LinkedList<>();
        queue.offer(new Coordinate(sr,sc));

        int original = image[sr][sc];

        while(!queue.isEmpty()){
            Coordinate cur = queue.poll();
            int curX = cur.x;
            int curY = cur.y;

            if(image[curX][curY] == original){
                image[curX][curY] = newColor;
            }

            visited[curX][curY] = true;

            for(int i = 0;i<4;i++){
                int newX= curX + dx[i];
                int newY= curY + dy[i];

                if(!isValid(newX,newY,image,visited,original)){
                    continue;
                }

                queue.offer(new Coordinate(newX,newY));
                visited[newX][newY] = true;
            }
        }
        return image;
    }

    public boolean isValid(int x, int y,int[][] image,boolean[][] visited,int original){
        if(x<0||x>=image.length||y<0||y>=image[0].length){
            return false;
        }
        if(visited[x][y]){
            return false;
        }
        if(image[x][y]!=original){
            return false;
        }
        return true;
    }
}
```

# 841

```java
class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        if(rooms == null|| rooms.size() == 0){
            return false;
        }

        Queue<List<Integer>> queue = new LinkedList<>();
        queue.offer(rooms.get(0));

        Set<Integer> visited = new HashSet<>();
        visited.add(0);

        while(!queue.isEmpty()){
            List<Integer> list = queue.poll();

            for(int i : list){
                if(visited.contains(i)){
                    continue;
                }

                queue.offer(rooms.get(i));
                visited.add(i);
            }
        }

        if(rooms.size() == visited.size()){
            return true;
        }
        return false;
    }
}
```



# 845	

```java
class Solution {
    public int longestMountain(int[] arr) {
        int n = arr.length;
        int ans = 0;
        int left = 0;
        while(left+2 < n ){
            int right = left+1;
            if(arr[left]<arr[left+1]){
                while(right+1<n && arr[right]<arr[right+1]){
                    ++right;
                }
                if(right<n-1&&arr[right]>arr[right+1]){
                    while(right<n-1&&arr[right]>arr[right+1]){
                        ++right;
                    }
                    ans = Math.max(ans,right-left+1);
                }else{
                    ++right;
                }
            }
            left = right;
        }
        return ans;
    }
}
```

# 876

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```



# 969

```java
class Solution {
    LinkedList<Integer> res = new LinkedList<>();
    public List<Integer> pancakeSort(int[] arr) {
        
    sort(arr, arr.length);
       return res;
    }

     void sort(int[] arr,int n){
        if(n == 1) return;

        int maxNum = 0;
        int maxIndex = 0; 
        for(int i = 0;i<n;i++){
            if(arr[i]>maxNum){
                maxNum = arr[i];
                maxIndex = i;
            }
        }

        reverse(arr,0,maxIndex);
        res.add(maxIndex+1);
        reverse(arr,0,n-1);
        res.add(n);

        sort(arr,n-1);
    }

    void reverse(int[] arr,int i,int j){
        while(i<j){
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
}


https://labuladong.gitee.io/algo/4/32/133/
```

# 986

```java
class Solution {
    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
        List<int[]> ans = new ArrayList();
        int i = 0;
        int j = 0;
        while(i<firstList.length&&j<secondList.length){
            int left = Math.max(firstList[i][0],secondList[j][0]);
            int right = Math.min(firstList[i][1],secondList[j][1]);

            if(left<=right){
                ans.add(new int[]{left,right});
            }

            if(firstList[i][1]<secondList[j][1]){
                i++;
            }else{
                j++;
            }

        }

        return ans.toArray(new int[ans.size()][]);
    }
}
```

