# 1

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<Integer,Integer>();
        for(int i=0;i<nums.length;i++){
            if(map.containsKey(target-nums[i])){
                return new int[]{i,map.get(target-nums[i])};
            }
            map.put(nums[i],i);
        }
        return new int[0];
    }
}
pShs1JAofgwM@fakemailserver.com
```

# 3

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashMap<Character, Integer> map = new HashMap();
        int length = s.length();
        int left = 0;
        int right =0;
        int max = 0;
        while(right<length){
            char rightChar = s.charAt(right);
            right++;
            map.put(rightChar,map.getOrDefault(rightChar,0)+1);
            while(map.get(rightChar)>1){
                char leftChar = s.charAt(left);
                left++;
                map.put(leftChar,map.get(leftChar)-1);
                
            }
            max = Math.max(max,right-left);
        }
        
        return max;
    }
}
```



# 5

```java
class Solution {
    public String longestPalindrome(String s) {
        if(s == null||s.length()==0){
            return s;
        }

        int len = s.length();
        String longest = "";

        for(int i=0;i<len;i++){
            String odd = isPalindrome(s,i,i);
            String even = isPalindrome(s,i,i+1);

            if(odd.length()>longest.length()){
                longest = odd;
            }
            if(even.length()>longest.length()){
                longest = even;
            }

        }

        return longest;

    }

    public String isPalindrome(String s,int left,int right){
        while(left>=0&&right<s.length()&&s.charAt(left)==s.charAt(right)){
            left--;
            right++;
        }
        return s.substring(left+1,right);
    }
}
```



# 11

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length-1;
        int max = 0;
        while(left<right){
            int area = (right-left)*Math.min(height[left],height[right]);
            max = Math.max(max,area);
            if(height[left]>height[right]){
                right--;
            }else{
                left++;
            }
        }
        return max;
    }
}
```

# 14

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs == null || strs.length == 0){
            return "";
        }
        int length = strs[0].length();
        int nums = strs.length;
        for(int i = 0;i<length;i++){
            char c = strs[0].charAt(i);
            for(int j = 1;j<nums;j++){
                if(i== strs[j].length() || c!=strs[j].charAt(i)){
                    return strs[0].substring(0,i);
                }
            }
        }
        return strs[0];
    }
}
```



# 15

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        for(int first = 0;first<n;first++){
            if(first>0&&nums[first]==nums[first-1]){
                continue;
            }
            int third = n-1;
            int target = -nums[first];

            for(int sec = first+1;sec <n;sec++){
                if(sec >first+1&&nums[sec]==nums[sec-1]){
                    continue;
                }
                while(sec<third&&nums[sec]+nums[third]>target){
                    third--;
                }
                if(third==sec){
                    break;
                }
                if(nums[sec]+nums[third]==target){
                    List<Integer> list = new ArrayList<Integer>();
                    list.add(nums[first]);
                    list.add(nums[sec]);
                    list.add(nums[third]);
                    ans.add(list);
                }
            }

        }
        return ans;
    }
}
```

# 19

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head == null) return null;
        int all;
        ListNode dummy = head;
        for(all =1;dummy.next !=null; all++){
            dummy =dummy.next;
        }
        ListNode temp = new ListNode(-1);
        temp.next = head;
        ListNode newTail = temp;
        for(int i =0;i<all-n;i++){
            newTail =newTail.next;
        }
        if(newTail == null){
            return null;
        }
        newTail.next = newTail.next.next;
        return temp.next;
    }
}
```

# 20

```java
class Solution {
    public boolean isValid(String s) {
        Deque<Character> queue = new LinkedList<>();
        char ch;
        for (int i = 0; i < s.length(); i++) {
            ch = s.charAt(i);
            if (ch == '[') {
                queue.push(']');
            } else if (ch == '{') {
                queue.push('}');
            } else if (ch =='(') {
                queue.push(')');
            } else if ( queue.isEmpty() || ch != queue.peek()) {
                return false;
            } else {
                queue.pop();
            }
        }
        return queue.isEmpty();
    }
}
```



# 21

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1==null){
            return list2;
        }else if(list2==null){
            return list1;
        }else if(list1.val<list2.val){
            list1.next =  mergeTwoLists(list1.next,list2);
            return list1;
        }else{
            list2.next =  mergeTwoLists(list1,list2.next);
            return list2;
        }
    }
}
```

# 24

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode temp = dummy;
        while(temp.next!=null && temp.next.next !=null){
            ListNode node1= temp.next;
            ListNode node2= temp.next.next;
            node1.next = node2.next;
            node2.next = node1;
            temp.next = node2;
            temp = node1;
        }
        return dummy.next;
    }
}
```



# 26	

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        int slow = 0;
        int fast = 0;
        while(fast<nums.length){
            if(nums[slow] != nums[fast]){
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
        }
        return slow+1;
    }
}
```

# 27

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int fast = 0;
        int slow = 0;
        while(fast<nums.length){
            if(nums[fast] != val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
}
```



# 28

```java
class Solution {
    public int strStr(String haystack, String needle) {
        int n = haystack.length();
        int m = needle.length();
        char[] h = haystack.toCharArray();
        char[] e = needle.toCharArray();
        for (int i = 0; i <= n - m; i++) {
            int a = i, b = 0;
            while (b < m && h[a] == e[b]) {
                a++;
                b++;
            }
            if (b == m)
                return i;
        }
        return -1;
    }
}
```



# 34

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        if (nums.length == 0) {
            return new int[] { -1, -1 };
        }
        int left = getFirst(nums, target);
        int right = getSec(nums, target);

        return new int[] { left, right };
    }

    public int getFirst(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left + 1 < right) {
            int mid = (right + left) / 2;
            if (nums[mid] > target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid;
            } else {
                right = mid;
            }
        }

        if (nums[left] == target) {
            return left;
        } else if (nums[right] == target) {
            return right;
        } else {
            return -1;
        }
    }

    public int getSec(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left + 1 < right) {
            int mid = (right + left) / 2;
            if (nums[mid] > target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid;
            } else {
                left = mid;
            }
        }

        if (nums[right] == target) {
            return right;
        } else if (nums[left] == target) {
            return left;
        } else {
            return -1;
        }
    }
}
```



# 35

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            int mid = (right + left)/2;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] < target){
                left = mid +1;
            }else {
                right = mid -1;
            }
        }
        return left;
    }
}
```



# 42

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int[] lmax = new int[n];
        int[] rmax  = new int[n];
        lmax[0] = height[0];
        rmax[n-1] = height[n-1];
        int ans = 0;
        for(int i=1;i<n;i++){
            lmax[i] = Math.max(height[i],lmax[i-1]);
        }
        for(int i = n-2;i>=0;i--){
            rmax[i] = Math.max(height[i],rmax[i+1]);
        }  
        for(int i = 1;i<n-1;i++){
            ans += Math.min(lmax[i]-height[i],rmax[i]-height[i]);
        } 
        return ans;
    }
}
```

# 53

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = nums[0];
        int pre = 0;
        for(int num:nums){
            pre = Math.max(pre+num,num);
            ans = Math.max(pre,ans);
        }
        return ans;
    }
}
```

# 54

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;

        int upper = 0;
        int left = 0;
        int lower = m - 1;
        int right = n - 1;
        List<Integer> ans = new LinkedList<>();
        while (ans.size() < m * n) {
            if (upper <= lower) {
                for (int j = left; j <= right; j++) {
                    ans.add(matrix[upper][j]);
                }
                upper++;
            }

            if (left <= right) {
                for (int i = upper; i <= lower; i++) {
                    ans.add(matrix[i][right]);
                }
                right--;
            }

            if (upper <= lower) {
                for (int j = right; j >= left; j--) {
                    ans.add(matrix[lower][j]);
                }
                lower--;
            }

            if (left <= right) {
                for (int i = lower; i >= upper; i--) {
                    ans.add(matrix[i][left]);
                }
                left++;
            }

        }
        return ans;
    }
}
```

​	

# 56

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals == null||intervals.length==0||intervals[0]==null||intervals[0].length==0){
            return new int[0][0];
        }
        Arrays.sort(intervals, (v1, v2) -> v1[0] - v2[0]);
        List<int[]> mergeList = new ArrayList<>();


        for(int i=0;i<intervals.length;i++){
            int left = intervals[i][0];
            int right = intervals[i][1];

            if(mergeList.size()==0||mergeList.get(mergeList.size()-1)[1]<left){
                mergeList.add(new int[]{left,right});
            }else{
                mergeList.get(mergeList.size()-1)[1] = Math.max(right,mergeList.get(mergeList.size()-1)[1]);
            }
        }

        int[][] results = new int[mergeList.size()][2];
        for(int i=0;i<mergeList.size();i++){
            results[i] = mergeList.get(i);
        }
        return results;
    }
}
```



# 69

```java
class Solution {
    public int mySqrt(int x) {
        int left = 0;
        int right = x;
        int ans = -1;
        while (left <= right) {
            int mid = (right + left) / 2;
            if ((long) mid * mid == x) {
                return mid;
            } else if ((long)mid * mid > x) {
                right = mid - 1;
            } else {
                ans = mid;
                left = mid + 1;
            }
        }
        return ans;
    }
}
```



# 75

```java
class Solution {
    public void sortColors(int[] nums) {
        int n = nums.length;
        int p0=0;
        int p1=0;
        for(int i=0;i<n;i++){
            if(nums[i]==1){
                int temp = nums[i];
                nums[i] = nums[p1];
                nums[p1] = temp;
                ++p1;
            }else if(nums[i]==0){
                int temp = nums[i];
                nums[i] = nums[p0];
                nums[p0] = temp;
                if(p0<p1){
                    temp = nums[i];
                    nums[i] = nums[p1];
                    nums[p1] = temp;
                }
                ++p0;
                ++p1;
            }
        }
    }
}
```



# 76

```java
class Solution {
    public String minWindow(String s, String t) {
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        for (char c : t.toCharArray()) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }

        int left = 0;
        int right = 0;
        int valid = 0;
        int start = 0;
        int ans = Integer.MAX_VALUE;

        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            if (need.containsKey(c)) {
                window.put(c, window.getOrDefault(c, 0) + 1);
                if (need.get(c).equals(window.get(c))) {
                    valid++;
                }
            }

            while (valid == need.size()) {
                if (right - left < ans) {
                    start = left;
                    ans = right - left;
                }

                char l = s.charAt(left);
                left++;
                if (need.containsKey(l)) {
                    if (need.get(l).equals(window.get(l))) {
                        valid--;
                    }
                    window.put(l, window.get(l) - 1);
                }
            }
        }

        return ans == Integer.MAX_VALUE ? "" : s.substring(start, start + ans);
    }
}
```

# 77

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        dfs(1,n,k);
        return res;
    }

    public void dfs(int start, int n,int k){
        if(k == path.size()){
            res.add(new ArrayList<>(path));
        }
        for(int i =start;i<=n;i++){
            path.add(i);
            dfs(i+1,n,k);
            path.remove(path.size()-1);
        }
    }
}
```



# 80	

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int left = 2;
        int right =2;
        if(nums.length <= 2){
            return nums.length;
        }
        while(right<nums.length){
            if(nums[left-2]==nums[right]){
                right++;
            }else{
                nums[left]=nums[right];
                right++;
    
                left++;                                                                
            }
        }
        return left;
    }
}
```

# 86

```java
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode small = new ListNode(0);
        ListNode smallHead = small;
        ListNode large = new ListNode(0);
        ListNode largeHead = large;
        while (head != null) {
            if (head.val < x) {
                small.next = head;
                small = small.next;
            } else {
                large.next = head;
                large = large.next;
            }
            head = head.next;
        }
        large.next = null;
        small.next = largeHead.next;
        return smallHead.next;
    }
}
```

# 94

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode node = root;

        while(node!=null||!stack.isEmpty()){
            if(node!=null){
                stack.push(node);
                node = node.left;
            }else{
                node = stack.pop();
                res.add(node.val);
                node=node.right;
            }
        }
        return res;
    }
}
```

# 88

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 =0;
        int p2 = 0;
        int index = 0;
        int[] sorted = new int[m + n];
        while(p1<m && p2<n){
            if(nums1[p1]<=nums2[p2]){
                sorted[index]=nums1[p1];
                p1++;
            }else{
                 sorted[index]=nums2[p2];
                 p2++;
            }
            index++;
        }

        while(p1<m){
            sorted[index]=nums1[p1];
            p1++;
            index++;
        }
        while(p2<n){
            sorted[index]=nums2[p2];
            p2++;
            index++;
        }

        for(int i = 0;i<nums1.length;i++){
            nums1[i]=sorted[i];
        }
    }
}
```

# 98

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
         return isValidBST(root, null, null);
    }

    public boolean isValidBST(TreeNode root,TreeNode min,TreeNode max){
        if(root==null){
            return true;
        }

        if(min!=null&&root.val<=min.val){
            return false;
        }

        if(max!=null&&root.val>=max.val){
            return false;
        }

        return isValidBST(root.left,min,root)&&isValidBST(root.right,root,max);
    }
}
```



# 100

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null&&q==null){
            return true;
        }

        if (p == null || q == null) {
            return false;
        }

        if(p.val!=q.val){
            return false;
        }

        return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
    }
}
```

# 101

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root,root);
    }

    public boolean check(TreeNode left,TreeNode right){
        if(left == null&&right==null){
            return true;
        }

        if(left == null || right == null){
            return false;
        }

        if(left.val != right.val){
            return false;
        }

        return check(left.left,right.right)&&check(left.right,right.left);
    }
}
```



# 102

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root ==null){
            return new ArrayList<>();
        }

        List<List<Integer>> ans = new ArrayList<>();
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i = 0;i<size;i++){
                TreeNode node = queue.poll();
                if(node.left!=null){
                    queue.offer(node.left);
                }
                if(node.right !=null){
                    queue.offer(node.right);
                }

                list.add(node.val);
            }
            ans.add(list);
        }
        return ans;
    }
}
```



# 103

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if(root == null){
            return new ArrayList<>();
        }

        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int flag = 0;
        
        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> level = new LinkedList<>();
            for(int i = 0;i<size;i++){
                TreeNode node = queue.poll();
                if(node.left !=null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
                level.add(node.val);

            }
            if(flag%2!=0){
                Collections.reverse(level);
            }
            flag++;
            ans.add(level);

        }

        return ans;
    }
}
```

# 104

```java
class Solution {
    int max = 0;
    public int maxDepth(TreeNode root) {
        if(root == null){
            return max;
        }

        max_depth(root,1);
        return max;
    }

    public void max_depth(TreeNode root,int depth){
        if(root==null){
            return;
        }

        max = Math.max(max,depth);

        max_depth(root.left,depth+1);
        max_depth(root.right,depth+1);
    }
}
```

# 107

```java

class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        if(root == null){
            return new ArrayList<>();
        }
        List<List<Integer>> ans = new ArrayList<>();
        Queue<TreeNode> queue = new LinkedList<>();

        queue.offer(root);
        while(!queue.isEmpty()){
            int size= queue.size();
            List<Integer> list = new ArrayList<>();
            for(int i =0;i<size;i++){
                TreeNode node = queue.poll();
                if(node.left !=null){
                    queue.offer(node.left);
                }
                if(node.right!=null){
                    queue.offer(node.right);
                }
                list.add(node.val);
            }
            ans.add(list);  
        }
        Collections.reverse(ans);
        return ans;
    }
}
```



# 111

```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        if(root.left==null&&root.right ==null){
            return 1;
        }
        
        int min_depth = Integer.MAX_VALUE;
        if(root.left!=null){
            min_depth = Math.min(minDepth(root.left),min_depth);
        }

        if(root.right!=null){
            min_depth = Math.min(minDepth(root.right),min_depth);
        }

        return min_depth+1;
    }
}

class Solution {
    public int minDepth(TreeNode root) {
        int min = 0;
        if(root == null) return min;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            min++;
            int size = queue.size();
            for(int i = 0;i<size;i++){
                TreeNode node = queue.poll();
                if(node.left !=null){
                    queue.add(node.left);
                }
                if(node.right !=null){
                    queue.add(node.right);
                }
                if(node.right==null && node.left ==null){
                    return min;
                }
            }
        }
        return min;
    }
}
```

# 112

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null){
            return false;
        }

        return dfs(root,targetSum,0);
    }

    public boolean dfs(TreeNode root, int targetSum,int preSum){
        if(root==null){
            return false;
        }

        int curSum = preSum+root.val;

        if(root.left == null&&root.right==null&&curSum==targetSum){
            return true;
        }

        return  dfs( root.left,targetSum, curSum)|| dfs(root.right, targetSum, curSum);
    }
}
```



# 113

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<Integer> path = new ArrayList<>();
        dfs(root,targetSum,0,path);
        return res;
    }

    public void dfs(TreeNode root, int targetSum,int curSum, List<Integer> path){
        if(root == null){
            return;
        }
        curSum = curSum + root.val;
        path.add( root.val);

        if(root.left==null&&root.right==null&&targetSum==curSum){
            res.add(new ArrayList<>(path));
            path.remove(path.size()-1);
            return;
        }

        dfs(root.left,targetSum,curSum,path);
        dfs(root.right,targetSum,curSum,path);

        path.remove(path.size()-1);

    }
}
```

# 116

```java
class Solution {
    public Node connect(Node root) {
        if (root == null)
            return root;
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {

            int size = queue.size();
            for (int i = 0; i < size; i++) {
                Node node = queue.poll();
                if (i < size - 1) {
                    node.next = queue.peek();
                }
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
            }
        }
        return root;
    }
}
```



# 125

```java
class Solution {
    public boolean isPalindrome(String s) {
        StringBuffer sgood = new StringBuffer();
        int length = s.length();
        for(int i=0;i<length;i++){
            char c1 = s.charAt(i);
            if(Character.isLetterOrDigit(c1)){
                sgood.append(Character.toLowerCase(c1));
            }
        }
        StringBuffer temp = new StringBuffer(sgood);
        StringBuffer reversed  = temp.reverse();
        
     
        return sgood.toString().equals(reversed.toString());
    }
}
```



# 141

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
```

# 142

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(true){
            if(fast == null ||fast.next == null) return null;
            fast = fast.next.next;
            slow = slow.next;
            if(fast==slow) break;
        }
        fast = head;
        while(fast != slow){
            fast = fast.next;
            slow = slow.next;
        }
        return fast;
    }
}
```



# 144

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode node =root;

        while(node!=null||!stack.isEmpty()){
            if(node!=null){
                res.add(node.val);
                stack.push(node);
                node=node.left;
            }else{
                node=stack.pop();
                node=node.right;
            }
        }
        return res;
    }
}
```

# 145

```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode node = root;
        while (node != null || !stack.isEmpty()) {
            if (node != null) {
                ans.add(0,node.val);
                stack.push(node);
                node = node.right;
            } else {
                node = stack.pop();
                node = node.left;
       
            }
        }
        return ans;
    }
}
```





# 146

```java
class Solution {
    public int[] spiralArray(int[][] array) {
        if (array == null || array.length == 0)
            return new int[0];
        int m = array.length;
        int n = array[0].length;

        int left = 0;
        int upper = 0;
        int right = n - 1;
        int lower = m - 1;
        int[] ans = new int[m * n];
        int start = 0;

        while (start < m * n) {
            if (upper <= lower) {
                for (int j = left; j <= right; j++) {
                    ans[start] = array[upper][j];
                    start++;
                }
                upper++;
            }

            if (left <= right) {
                for (int i = upper; i <= lower; i++) {
                    ans[start] = array[i][right];
                    start++;
                }
                right--;
            }

            if (upper <= lower) {
                for (int j = right; j >= left; j--) {
                    ans[start] = array[lower][j];
                    start++;
                }
                lower--;
            }

            if (left <= right) {
                for (int i = lower; i >= upper; i--) {
                    ans[start] = array[i][left];
                    start++;
                }
                left++;
            }
        }

        return ans;
    }
}
```

# 150

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> queue = new LinkedList<>();
        for (int i = 0; i < tokens.length; i++) {
            String s = tokens[i];
            if (s.equals("+")) {
                queue.push(queue.pop() + queue.pop());
            } else if (s.equals("-")) {
                queue.push(-queue.pop() + queue.pop());
            } else if (s.equals("*")) {
                queue.push(queue.pop() * queue.pop());
            } else if (s.equals("/")) {
                int temp1 = queue.pop();
                int temp2 = queue.pop();
                queue.push(temp2 / temp1);
            } else {
                queue.push(Integer.valueOf(s));
            }
        }
        return queue.pop();
    }
}
```



# 151

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    let i =0,j=1,result ='',len = s.length;
    while(i<len){
       if(s[i]===' '){
           i++;
       }else{
           j=i+1;
           let ret = s[i];
           while(j<len){
               if(s[j]===' '){
                   break;
               }
               ret += s[j];
               j++;
           }
           result = ret + (result.length ? ' ' + result : '');
           i=j;
       }
    }
    return result;
};
```



```java
class Solution {
    public String reverseWords(String s) {
        s = s.trim();
        int j = s.length() - 1;
        int i = j;
        StringBuilder res = new StringBuilder();

        while (i >= 0) {
            while (i >= 0 && s.charAt(i) != ' ') {
                i--;
            }
            res.append(s.substring(i + 1, j + 1) + ' ');
            while (i >= 0 && s.charAt(i) == ' ') {
                i--;
            }
            j = i;
        }
        return res.toString().trim();
    }
}
```



# 160

```java	

public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode a = headA;
        ListNode b = headB;
        if (headA == null || headB == null) return null;
        int aSize = 0;
        int bSize = 0;
       
        while(a!=null){
            aSize++;
            a = a.next;
        }
        while(b!=null){
            bSize++;
            b = b.next;
        }
        int diff = aSize-bSize;
        if(diff > 0){
            for(int i =0;i<diff;i++){
                headA = headA.next;
            }
 
        }else{
            diff=-diff;
            System.out.println(diff);
            for(int j =0;j<diff;j++){
                headB = headB.next;
            }

        }
        while(headA !=null){
            if(headA == headB){
                return headA;
            }else{
                headA = headA.next;
                headB = headB.next;
            }
        }
        return null;
    }
}
```



# 167

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length-1;
        while(left<right){
            if(numbers[left]+numbers[right] >target){
                right--;
            }else if(numbers[left]+numbers[right] < target){
                left++;
            }else{
                return new int[]{left+1,right+1};
            }
        }
        return new int[]{-1,1};
    }
}
```

# 173

```java
class BSTIterator {

    List<Integer> list = new LinkedList<>();
    public BSTIterator(TreeNode root) { 
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode node = root;
        while(node!=null||!stack.isEmpty()){
            if(node!=null){
                stack.push(node);
                node = node.left;
            }else{
                node = stack.pop();
                list.add(node.val);
                node= node.right;
            }
        }
    }
    
    public int next() {
        return list.remove(0);
    }
    
    public boolean hasNext() {
        return !list.isEmpty();
    }
}

```

# 199

```java
class Solution {
     List<Integer> res = new ArrayList<>();
    public List<Integer> rightSideView(TreeNode root) {
        if(root==null){
            return res;
        }

        Queue<TreeNode> queue  = new LinkedList<>();
        queue.offer(root);

        while(!queue.isEmpty()){
            int size = queue.size();
            List<Integer> layer = new ArrayList<>();

            for(int i =0;i<size;i++){
                TreeNode node = queue.poll();
                layer.add(node.val);

                if(node.left!=null){
                    queue.offer(node.left);
                }
                if(node.right!=null){
                    queue.offer(node.right);
                }
            }

            res.add(layer.get(layer.size()-1));
        }

        return res;
    }
}
```

# 200

```java
class Coordinate{
    int x;
    int y;
    public Coordinate(int x, int y){
        this.x=x;
        this.y=y;
    }
}


class Solution {
    public static int[] directionX = new int[] {-1,0,1,0};
    public static int[] directionY= new int[] {0,1,0,-1};
    public int numIslands(char[][] grid) { 
        if(grid==null||grid.length==0||grid[0]==null||grid[0].length==0){
            return 0;
        }
        int row = grid.length;
        int col = grid[0].length;

        int numIslands=0;
        boolean[][] visited = new boolean[row][col];
        
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(grid[i][j] == '1' && !visited[i][j]){
                    bfs(i,j,grid,visited);
                    numIslands++;
                }
            }
        }
        return numIslands;
    }

    public void bfs(int x, int y, char[][] grid, boolean[][] visited){
        Queue<Coordinate> queue = new LinkedList<>();
        queue.offer(new Coordinate(x,y));

        visited[x][y] = true;

        while(!queue.isEmpty()){
            Coordinate curr = queue.poll();

            for(int i=0;i<4;i++){
                int newX = curr.x + directionX[i];
                int newY = curr.y + directionY[i];

                if(!isValid(newX,newY,grid,visited)){
                    continue;
                }

                queue.offer(new Coordinate(newX,newY));
                visited[newX][newY] = true;
            }
        }
    }

    public boolean isValid(int x, int y, char[][] grid, boolean[][] visited){
        if(x<0||x>=grid.length||y<0||y>=grid[0].length){
            return false;
        }
        if(visited[x][y] == true){
            return false;
        }

        return grid[x][y] == '1';
    }
}
```

# 203

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode temp = dummy;
        while(temp.next != null){
            if(temp.next.val == val){
                temp.next = temp.next.next;
            }else{
                temp = temp.next;
            }
        }
        return dummy.next;
    }
}
```



# 206

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        ListNode last = reverseList(head.next);
        head.next.next= head;
        head.next =null;
        return last;
    }
}
```



# 209

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int right = 0;
        int min = Integer.MAX_VALUE;
        int sum = 0;

        while(right<nums.length){
            sum +=nums[right];
            while(sum>=target){
                min = Math.min(min,right-left+1);
                sum -= nums[left];
                left++;
            }
            right++;
        }
        return min == Integer.MAX_VALUE ? 0:min;

    }
}
```



# 215

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int length = nums.length;
        PriorityQueue<Integer> miniHeap = new PriorityQueue<>(k,(a,b)->a-b);
        for(int i =0;i<k;i++){
            miniHeap.add(nums[i]);
        }
        for(int j = k;j<length;j++){
            if(nums[j]>miniHeap.peek()){
                miniHeap.poll();
                miniHeap.offer(nums[j]);
            }
        }
        return miniHeap.peek();
    }
}
```

# 226

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null)
            return null;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            TreeNode temp = node.left;
            node.left = node.right;
            node.right = temp;
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
        return root;
    }
}
```



# 230

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        ArrayList<Integer> list = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode node = root;

        while(!stack.isEmpty()||node != null){
            if(node!=null){
                stack.push(node);
                node = node.left;
            }else{
                node=stack.pop();
                list.add(node.val);
                node=node.right;
                
            }
        }
       return list.get(k-1);
    }
}
```



# 234

```java

class Solution {
    public boolean isPalindrome(ListNode head) {
        List<Integer> vals = new ArrayList<Integer>();
        ListNode node = head;
        while(node!=null){
            vals.add(node.val);
            node = node.next;
        }

        int start=0;
        int end = vals.size()-1;
        while(start<end){
            if(vals.get(start)!=vals.get(end)){
                return false;
            }else{
                start++;
                end--;
            }
        }
        return true;
    }
}
```



# 238

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int length = nums.length;
        int[] l = new int[length];
        int[] r = new int[length];
        int[] ans = new int[length];

        l[0]=1;
        for(int i=1;i<length;i++){
            l[i] = nums[i-1]*l[i-1];
        }
        
        r[length-1]=1;
        for(int i=length-2;i>=0;i--){
           r[i] = r[i+1]*nums[i+1];
        }

        for(int i= 0;i<length;i++){
            ans[i] = l[i]*r[i];
        }

        return ans;
    }
}
```

# 242

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length())
            return false;
        int[] list = new int[26];
        for (int i = 0; i < s.length(); i++) {
            list[s.charAt(i) - 'a']++;
            list[t.charAt(i) - 'a']--;
        }
        for (int i = 0; i < 26; i++) {
            if (list[i] != 0)
                return false;
        }
        return true;
    }
}
```



# 283

```java
class Solution {
    public void moveZeroes(int[] nums) {
        if(nums==null){
            return;
        }
        int p1 = 0;
        int p2 = 0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=0){
                int temp = nums[p2];
                nums[p2]=nums[i];
                nums[p1]=temp;
                p2++;
            }
            p1++;
        }
    }
}
```

# 287

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int length = nums.length;
        int[] index = new int[length+1];
        for(int i = 0;i<length;i++){
            if(index[nums[i]]==1){
                return nums[i];
            }else{
               index[nums[i]]=1;
            }
        }
        return 0;
    }
}
```

# 303

```java
class NumArray {
    int[] sums;

    public NumArray(int[] nums) {
        int n = nums.length;
        sums = new int[n+1];
        for(int i =0;i<n;i++){
            sums[i+1] = nums[i]+sums[i];
        }
    }
    
    public int sumRange(int left, int right) {
        return sums[right+1]-sums[left];
    }
}
```



# 328

```java
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head == null) {
            return head;
        }
        ListNode evenHead = head.next;
        ListNode odd = head, even = evenHead;
        while (even != null && even.next != null) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }
}
```

# 343

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n+1];
        for(int i=2;i<=n;i++){
            int max=0;
            for(int j=1;j<i;j++){
                max= Math.max(max,Math.max(j*(i-j),j*dp[i-j]));
            }
            dp[i] = max;
        }
        return dp[n];
    }
}
```



# 344

```java
class Solution {
    public void reverseString(char[] s) {
        int first = 0;
        int last = s.length - 1;
        while (first < last) {
            char temp = s[first];
            s[first] = s[last];
            s[last] = temp;
            first++;
            last--;
        }
    }
}
```



# 345

```java	
class Solution {
    public String reverseVowels(String s) {
        int n = s.length();
        char[] arr = s.toCharArray();
        int i =0;
        int j = n-1;
        while(i<j){
            while(i<n&&!isAEIOU(arr[i])){
                i++;
            }
            while(j>0&&!isAEIOU(arr[j])){
                j--;
            }
            if(i<j){
                swap(arr,i,j);
                i++;
                j--;
            }
        }
        return new String(arr);

    }

    public Boolean isAEIOU(char c){
        return "aeiouAEIOU".indexOf(c)>=0;
    }

    public void swap(char[] arr,int i,int j){
        char temp = arr[i];
        arr[i]=arr[j];
        arr[j] = temp;
    }
}
```



# 347

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer,Integer> map = new HashMap();
        for(int num : nums){
            if(map.containsKey(num)){
                map.put(num,map.get(num)+1);
            }else{
                map.put(num,1);
            }
        }

        PriorityQueue<Integer> miniHeap = new PriorityQueue<>(new Comparator<Integer>(){
            @Override
            public int compare(Integer a, Integer b){
                return map.get(a) - map.get(b);
            }
        });
        for(int key : map.keySet()){
            if(miniHeap.size()<k){
                miniHeap.add(key);
            }else{
                if(map.get(key)>map.get(miniHeap.peek())){
                    miniHeap.remove();
                    miniHeap.add(key);
                }
            }
        }

        int[] ans  = new int[k];
        for(int i = 0; i < k; i++){
            ans[i] = miniHeap.poll();
        }
        return ans;
    }
}
```

# 349

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int l1=nums1.length;
        int l2=nums2.length;
        int[] ans = new int[l1+l2];
        int index1=0;
        int index2=0;
        int index=0;
        while(index1<l1&&index2<l2){
            if(nums1[index1]==nums2[index2]){
                if(index==0||ans[index-1]!=nums1[index1]){
                    ans[index]=nums1[index1];
                    index++;
                }
                index2++;
                index1++;
            }else if(nums1[index1]>nums2[index2]){
                index2++;
            }else{
                index1++;
            }
        
        }
        ans = Arrays.copyOfRange(ans, 0, index);
        return ans; 
    }
}
```

# 350

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        if(nums1.length>nums2.length){
            return intersect( nums2, nums1);
        }

        HashMap<Integer,Integer> map = new HashMap<Integer, Integer>();
        for(int num : nums1){
            int counter = map.getOrDefault(num,0)+1;
            map.put(num,counter);
        }

        int index = 0;
        int[] ans = new int[nums1.length];
        for(int num:nums2){
            int counter = map.getOrDefault(num,0);
            if(counter>0){
                ans[index] = num;
                index++;
                counter--;
                if(counter==0){
                    map.remove(num);
                }else{
                    map.put(num,counter);
                }
            }
        }
        ans = Arrays.copyOfRange(ans, 0, index);
        return ans;
    }
}
```

# 367

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        int left = 0;
        int right = num;
        while (left <= right) {
            int mid = (left + right) / 2;
            if ((long) mid * mid == num) {
                return true;
            } else if ((long) mid * mid > num) {
                right = mid - 1;
            } else {
                left = mid + 1;

            }
        }
        return false;
    }
}
```



# 383

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        if (ransomNote.length() > magazine.length())
            return false;
        int[] record = new int[26];

        for (int i = 0; i < magazine.length(); i++) {
            record[magazine.charAt(i) - 'a']++;
        }

        for (int i = 0; i < ransomNote.length(); i++) {
            record[ransomNote.charAt(i) - 'a']--;
        }

        for (int i = 0; i < 26; i++) {
            if (record[i] < 0)
                return false;
        }
        return true;

    }
}
```

# 404

```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root == null) return 0;
        int left = sumOfLeftLeaves(root.left);
        int right = sumOfLeftLeaves(root.right);
        int mid = 0;
        if(root.left !=null && root.left.left==null &&root.left.right==null){
            mid = root.left.val;
        }
        int sum = mid + left +right;
        return sum;
    }
}
```



# 429

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null)
            return res;
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                Node node = queue.poll();

                if (node.children != null) {

                    for (int j = 0; j < node.children.size(); j++) {
                        Node child = node.children.get(j);
                        queue.add(child);

                    }
                }
                list.add(node.val);
            }
            System.out.print(list);
            res.add(list);
        }
        return res;
    }
}
```



# 442

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDuplicates = function(nums) {
    const n = nums.length;
    const ans = [];
    for(let i = 0;i<n;i++){
      const x = Math.abs(nums[i]);
        if (nums[x - 1] > 0) {
            nums[x - 1] = -nums[x - 1];
            console.log( nums[x - 1])
        } else {
            ans.push(x);
        }
    }
       console.log(ans)
       return ans;
};
```

# 494

```java
class Solution {
    int count = 0;
    public int findTargetSumWays(int[] nums, int target) {
        back(nums,target,0,0);
        return count;
    }

    public void back(int[] nums, int target, int index,int sum){
        if(index == nums.length){
            if(sum == target){
                count ++;
            }
        }else{
            back(nums,target,index+1, sum+nums[index]);
            back(nums,target,index+1, sum-nums[index]);
        }
    }
}
```

# 485

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count = 0;
        int max = 0;
        for(int i =0;i<nums.length;i++){
            if(nums[i]==1){
                count++;
            }else{
                max = Math.max(max,count);
                count =0;
            }
        }
        return Math.max(max,count);
    }
}
```



# 509

````java
class Solution {
    public int fib(int n) {
        if(n<2) return n;
        int p=0;
        int q=0;
        int r=1;
        for(int i=1;i<n;i++){
            p=q;
            q=r;
            r=p+q;
        }
        return r;
    }
}
````



# 513

```java

class Solution {
    public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        TreeNode node = null;
        queue.offer(root);
        while(!queue.isEmpty()){
            node = queue.poll();
            if(node.right !=null){
                queue.offer(node.right);
            }
             if(node.left!=null ){
                queue.offer(node.left);
            }
        }
        return node.val;
    }
}
```

# 515

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null)
                    queue.add(node.left);
                if (node.right != null)
                    queue.add(node.right);
                list.add(node.val);
            }
            res.add(Collections.max(list));
        }
        return res;
    }
}
```



# 543

```java
class Solution {
    int max = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root==null){
            return 0;
        }

        dfs(root);
        return max;
    }

    public int dfs(TreeNode root){
        if(root == null){
            return 0;
        }

        int maxLeft = dfs(root.left);
        int maxRight = dfs(root.right);
        max = Math.max(max,maxLeft+maxRight);
 
        return Math.max(maxLeft,maxRight)+1;
    }
}
```



# 557

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    const ret = [];
    let i = 0;
    len = s.length;
    while(i<len){
        let start = i;
        while(s.charAt(i)!= ' '&&i<len){
            i++;
        }
        for(let p = start;p<i;p++){
            ret.push(s.charAt(i-1+start-p));
        }
        while(i<len&&s.charAt(i) == ' '){
            i++;
            ret.push(' ');
        }
        console.log(ret)
    }
    return ret.join('');
};
```



# 567

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        Map<Character,Integer> need = new HashMap<>();
        Map<Character,Integer> window = new HashMap<>();
        int left = 0;
        int right = 0;
        int count = 0;

        for(int i = 0;i<s1.length();i++){
            char c = s1.charAt(i);
            need.put(c,need.getOrDefault(c,0)+1);
        }

        while(right<s2.length()){
            char rightChar = s2.charAt(right);
            right++;
            if(need.containsKey(rightChar)){
                window.put(rightChar,window.getOrDefault(rightChar,0)+1);
                if(need.get(rightChar).equals(window.get(rightChar))){
                    count++;
                }
            }

            while(right - left >= s1.length()){
                if(count == need.size()){
                    return true;
                }

                char leftChar = s2.charAt(left);
                left++;

                if(need.containsKey(leftChar)){
                    if(need.get(leftChar).equals(window.get(leftChar))){
                        count--;
                    }
                    window.put(leftChar,window.get(leftChar)-1);
                }
            }
        }

        return false;
    }
}
```

# 653	

```java
class Solution {
   List<Integer> list = new ArrayList<Integer>();
    public boolean findTarget(TreeNode root, int k) {
        getTreeArray(root);
      
        int left = 0;
        int right = list.size()-1;
       while(left<right){
        if(list.get(left)+list.get(right)>k){
            right--;
        }else if(list.get(left)+list.get(right)<k){
            left++;
        }else{
            return true;
        }
       }
  
        return false;
    }

    public void getTreeArray(TreeNode root){
        if(root == null ){
            return;
        }
      
        getTreeArray(root.left);
        list.add(root.val);
        getTreeArray(root.right);
        


    }
}
```



# 680

```java
class Solution {
    public boolean validPalindrome(String s) {
        int start = 0;int end = s.length() -1;
        while(start<end){
            char c1 = s.charAt(start);
            char c2 = s.charAt(end);
            if(c1==c2){
                start++;
                end--;
            }else{
                return isPalindrome( s, start+1, end)||isPalindrome( s, start, end-1);
            }
        }
        return true;
    }

    public boolean isPalindrome(String s,int start,int end){
        for(int i=start,j = end;i<j;i++,j--){
            char c1 = s.charAt(i);
            char c2 = s.charAt(j);
            if(c1!=c2){
                return false;
            }
        }
        return true;
    }
}
```

# 703

```java
class KthLargest {
    PriorityQueue<Integer> pq;
    int k;

    public KthLargest(int k, int[] nums) {
        this.k = k;
        pq = new PriorityQueue<>();
        for(int num:nums){
            add(num);
        }
    }
    
    public int add(int val) {
        pq.offer(val);
        if(pq.size()>k){
            pq.poll();
        }
        return pq.peek();
    }
}
```

# 704

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length-1;
        while(left+1<right){
            int mid = left+(right-left)/2;
            if(nums[mid]>target){
                right= mid;
            }else if(nums[mid]<target){
                left=mid;
            }else{
                return mid;
            }
        }
        
        if(nums[left]==target){
            return left;
        }
        if(nums[right]==target){
            return right;
        }
        return -1;
    }
}
```

# 724

```java
class Solution {
    public int pivotIndex(int[] nums) {
        int sum = 0;
        int leftSum = 0;
        for(int num : nums){
            sum = sum+num;
        }
        for(int i = 0;i<nums.length;i++){
            int right = sum - nums[i] - leftSum;
            if(right == leftSum){
                return i;
            }
            leftSum += nums[i];


        }
        return -1;
    }
}
```



# 733

```java
class Coordinate{
    int x;
    int y;
    public Coordinate(int x, int y){
        this.x = x;
        this.y=y;
    }
}

class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        if(image == null||image.length==0||image[0]==null||image[0].length==0){
            return new int[0][0];
        }

        int row = image.length;
        int col = image[0].length;

        int[] dx = new int[]{0,0,-1,1};
        int[] dy = new int[]{-1,1,0,0};

        boolean[][] visited = new boolean[row][col];

        Queue<Coordinate> queue = new LinkedList<>();
        queue.offer(new Coordinate(sr,sc));

        int original = image[sr][sc];

        while(!queue.isEmpty()){
            Coordinate cur = queue.poll();
            int curX = cur.x;
            int curY = cur.y;

            if(image[curX][curY] == original){
                image[curX][curY] = newColor;
            }

            visited[curX][curY] = true;

            for(int i = 0;i<4;i++){
                int newX= curX + dx[i];
                int newY= curY + dy[i];

                if(!isValid(newX,newY,image,visited,original)){
                    continue;
                }

                queue.offer(new Coordinate(newX,newY));
                visited[newX][newY] = true;
            }
        }
        return image;
    }

    public boolean isValid(int x, int y,int[][] image,boolean[][] visited,int original){
        if(x<0||x>=image.length||y<0||y>=image[0].length){
            return false;
        }
        if(visited[x][y]){
            return false;
        }
        if(image[x][y]!=original){
            return false;
        }
        return true;
    }
}
```

# 747

```java
class Solution {
    public int dominantIndex(int[] nums) {
        int max= nums[0];
        int maxIndex = 0;
        for(int i = 0;i<nums.length;i++){
            if(nums[i] >max){
                max = nums[i];
                maxIndex=i;
            }
        }
        for(int i = 0;i<nums.length;i++){
            if(i != maxIndex && nums[i]*2 > max){
                return -1;
            }
        }
        return maxIndex;
    }
}
```

# 841

```java
class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        if(rooms == null|| rooms.size() == 0){
            return false;
        }

        Queue<List<Integer>> queue = new LinkedList<>();
        queue.offer(rooms.get(0));

        Set<Integer> visited = new HashSet<>();
        visited.add(0);

        while(!queue.isEmpty()){
            List<Integer> list = queue.poll();

            for(int i : list){
                if(visited.contains(i)){
                    continue;
                }

                queue.offer(rooms.get(i));
                visited.add(i);
            }
        }

        if(rooms.size() == visited.size()){
            return true;
        }
        return false;
    }
}
```



# 844

```java
class Solution {
    public boolean backspaceCompare(String s, String t) {
        int i = s.length() - 1;
        int j = t.length() - 1;

        int skipI = 0;
        int skipJ = 0;
        while (i >= 0 || j >= 0) {
            while (i >= 0) {
                if (s.charAt(i) == '#') {
                    i--;
                    skipI++;
                } else if (skipI > 0) {
                    skipI--;
                    i--;
                } else {
                    break;
                }
            }
            while (j >= 0) {
                if (t.charAt(j) == '#') {
                    j--;
                    skipJ++;
                } else if (skipJ > 0) {
                    skipJ--;
                    j--;
                } else {
                    break;
                }
            }
            if (i >= 0 && j >= 0) {
                if (s.charAt(i) != t.charAt(j)) {
                    return false;
                }
            } else {
                if (i >= 0 || j >= 0) {
                    return false;
                }

            }
            i--;
            j--;
        }
        return true;
    }
}
```



# 845	

```java
class Solution {
    public int longestMountain(int[] arr) {
        int n = arr.length;
        int ans = 0;
        int left = 0;
        while(left+2 < n ){
            int right = left+1;
            if(arr[left]<arr[left+1]){
                while(right+1<n && arr[right]<arr[right+1]){
                    ++right;
                }
                if(right<n-1&&arr[right]>arr[right+1]){
                    while(right<n-1&&arr[right]>arr[right+1]){
                        ++right;
                    }
                    ans = Math.max(ans,right-left+1);
                }else{
                    ++right;
                }
            }
            left = right;
        }
        return ans;
    }
}
```

# 876

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
}
```



# 904

```java
class Solution {
    public int totalFruit(int[] fruits) {
        int left = 0;
        int right = 0;
        int ans = 0;
        int n = fruits.length;
        Map<Integer, Integer> map = new HashMap<>();

        while (right < n) {
            map.put(fruits[right], map.getOrDefault(fruits[right], 0) + 1);
            while (map.size() > 2) {
                map.put(fruits[left], map.get(fruits[left]) - 1);
                if (map.get(fruits[left]) == 0)
                    map.remove(fruits[left]);
                left++;
            }
            right++;
            ans = Math.max(ans, right - left);
        }
        return ans;
    }
}
```



# 969

```java
class Solution {
    LinkedList<Integer> res = new LinkedList<>();
    public List<Integer> pancakeSort(int[] arr) {
        
    sort(arr, arr.length);
       return res;
    }

     void sort(int[] arr,int n){
        if(n == 1) return;

        int maxNum = 0;
        int maxIndex = 0; 
        for(int i = 0;i<n;i++){
            if(arr[i]>maxNum){
                maxNum = arr[i];
                maxIndex = i;
            }
        }

        reverse(arr,0,maxIndex);
        res.add(maxIndex+1);
        reverse(arr,0,n-1);
        res.add(n);

        sort(arr,n-1);
    }

    void reverse(int[] arr,int i,int j){
        while(i<j){
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
}


https://labuladong.gitee.io/algo/4/32/133/
```

# 977

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        int i = 0;
        int j = n - 1;
        int index = n - 1;
        while (i <= j) {
            if (Math.abs(nums[i]) > Math.abs(nums[j])) {
                ans[index] = nums[i] * nums[i];
                i++;
            } else {
                ans[index] = nums[j] * nums[j];
                j--;
            }
            index--;
        }
        return ans;
    }
}
```



# 986

```java
class Solution {
    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
        List<int[]> ans = new ArrayList();
        int i = 0;
        int j = 0;
        while(i<firstList.length&&j<secondList.length){
            int left = Math.max(firstList[i][0],secondList[j][0]);
            int right = Math.min(firstList[i][1],secondList[j][1]);

            if(left<=right){
                ans.add(new int[]{left,right});
            }

            if(firstList[i][1]<secondList[j][1]){
                i++;
            }else{
                j++;
            }

        }

        return ans.toArray(new int[ans.size()][]);
    }
}
```

# 1047

```java
class Solution {
    public String removeDuplicates(String s) {
        Deque<Character> queue = new LinkedList<>();
        char ch;
        for (int i = 0; i < s.length(); i++) {
            ch = s.charAt(i);
            if (queue.isEmpty() || queue.peek() != ch) {
                queue.push(ch);
            } else {
                queue.pop();
            }
        }
        String ans = "";
        while (!queue.isEmpty()) {
            ans = queue.pop() + ans;
        }
        return ans;
    }
}
```



##### 

